/*  Program to implement Australian House of Representatives preferential
    voting and determine election outcomes from vote preference orderings.

    Skeleton program written by Alistair Moffat, ammoffat@unimelb.edu.au,
    August 2025, with the intention that it be modified by students
    to add functionality, as required by the assignment specification.
    All included code is (c) Copyright University of Melbourne, 2025

    Student Authorship Declaration:

    (1) I certify that except for the code provided in the initial skeleton
    file, the program contained in this submission is completely my own
    individual work, except where explicitly noted by further comments that
    provide details otherwise. I understand that work that has been
    developed by another student, or by me in collaboration with other
    students, or by non-students as a result of request, solicitation, or
    payment, may not be submitted for assessment in this subject. I
    understand that submitting for assessment work developed by or in
    collaboration with other students or non-students constitutes Academic
    Misconduct, and may be penalized by mark deductions, or by other
    penalties determined via the University of Melbourne Academic Honesty
    Policy, as described at https://academicintegrity.unimelb.edu.au.

    (2) I also certify that I have not provided a copy of this work in either
    softcopy or hardcopy or any other form to any other student, and nor will
    I do so until after the marks are released. I understand that providing
    my work to other students, regardless of my intention or any undertakings
    made to me by that other student, is also Academic Misconduct.

    (3) I further understand that providing a copy of the assignment
    specification to any form of code authoring or assignment tutoring
    service, or drawing the attention of others to such services and code
    that may have been made available via such a service, may be regarded as
    Student General Misconduct (interfering with the teaching activities of
    the University and/or inciting others to commit Academic Misconduct). I
    understand that an allegation of Student General Misconduct may arise
    regardless of whether or not I personally make use of such solutions or
    sought benefit from such actions.

    Signed by: [Hoang Phuc Le 1524189]
    Dated: [04/09/2025]
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <ctype.h>
#include <assert.h>
#define MAX_CAN 20
#define MAX_VOTE 999
#define MAX_CHAR 20 

///////////////////////////////////////////////////////////////////////

// add your other function prototypes here
void stage1(int can_num, char candidate_name[][20],
    int preference[][MAX_CAN], int vote_num);
int stage2(int can_num, int vote_num, int preference[][MAX_CAN],
    char candidate_name[][20]);
int check_winner(int vote_num,int can_num, char candidate_name[][20],
    int vote_count[], int active_candidate[]);
int find_eliminate(int vote_count[], int active_candidate[], int can_num);
void redistribute(int preference[][MAX_CAN], int vote_count[],
    int active_candidates[],int eliminate_candidate, int vote_num, int can_num);
int stage3(int can_num, int vote_num,
    int preference[][MAX_CAN], char candidate_name[][20]);
void sort_active_candidates(int sorted_indices[], int active_candidates[],
    int can_num, int vote_count[], char candidate_name[][20]);
int find_vote_owner(int vote_index, int preference[][MAX_CAN],
    int active_candidate[], int can_num);                           
    

///////////////////////////////////////////////////////////////////////

// main program provides traffic control
int main(int argc, char *argv[]) {
    // write your main program here
    // algorithms are fun

    // read candidate and voters info from input file
    int can_num;
    scanf("%d", &can_num);
    char candidate[MAX_CAN][MAX_CHAR];
    for (int i = 0; i < can_num; i++) {
        scanf("%s", candidate[i]);
    }
    int votes_preference[MAX_VOTE][MAX_CAN];
    int i = 0;  
    while (i < MAX_VOTE && scanf("%d", &votes_preference[i][0]) == 1) {
        for (int j = 1; j < can_num; j++) {
            if (scanf("%d", &votes_preference[i][j]) != 1) {
                break;
            }
        }
        i++;
    }

    // determine the number of voters
    int voters_num = i;

    // printing the outputs of programs
    printf("\n");
    stage1(can_num, candidate, votes_preference, voters_num);
    printf("\n");
    stage2(can_num, voters_num, votes_preference, candidate);
    printf("\n");
    printf("\n");
    stage3(can_num, voters_num, votes_preference, candidate);
    printf("\n");
    // all done, time to go home
    printf("tadaa!\n");

    return 0;
}


///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////

// add your other functions here
void stage1(int can_num, char candidate_name[][MAX_CHAR],
    int preference[][MAX_CAN], int vote_num){

    // print the layout for stage 1
    printf("Stage 1\n");
    printf("=======\n");
    printf("read %d candidates and %d votes\n", can_num, vote_num);
    printf("voter %d preferences...\n", vote_num);
    int rank[MAX_CAN+1];  

    // rank maps the number to candidate index
    for (int i = 0; i < can_num; i++) {
        int r = preference[vote_num-1][i];
        rank[r] = i;   
    }

    // print out from rank 1 to last 
    for (int i = 1; i <= can_num; i++) {
        int r = rank[i];
        printf("    rank%3d: %s\n", i, candidate_name[r]);
    }
}

int stage2(int can_num, int vote_num,
    int preference[][MAX_CAN], char candidate_name[][20]){

    // print stage 2 layout
    printf("Stage 2\n");
    printf("=======\n");
    int vote_count[can_num];
    int active_candidate[can_num];
    
    //set active status for every candidates
    for(int i = 0; i < can_num; i++){
        active_candidate[i] = 1;
    }

    // count votes per candidate
    for(int i = 0; i < can_num; i++){
        vote_count[i] = 0;
    }

    // count votes based on first preference
    for(int v = 0; v < vote_num; v++){
        for (int c = 0; c < can_num; c++){
            if(preference[v][c] == 1){
                vote_count[c]++;
                break;
            }
        }
    }

    // iterates logic to complete all the rounds needed
    int round = 1;
    while(1){
        // print the layout for stage 2
        printf("round %d...\n", round);

        for(int i = 0; i < can_num; i++){
            if(active_candidate[i]){
                double vote_ratio = 100.0*vote_count[i]/vote_num;
                printf("    %-20s: %3d votes, %5.1lf%%\n", 
                candidate_name[i], vote_count[i], vote_ratio);
            }
        }
        printf("    ----\n");

        // check if there is a winner
        int winner = check_winner(vote_num, can_num,
            candidate_name, vote_count, active_candidate);
        if(winner != -1){
            printf("    %s is declared elected\n", candidate_name[winner]);
            return winner;
        }
        
        // find suitable candidate to eliminate
        int eliminated = find_eliminate(vote_count, active_candidate, can_num);
        printf("    %s is eliminated and votes distributed\n\n",
            candidate_name[eliminated]);

        // redistribute votes after eliminating
        redistribute(preference, vote_count, active_candidate,
             eliminated, vote_num, can_num);

        // set value for eliminated candidate 
        active_candidate[eliminated] = 0;

        round++;
    }    
    
}
// check if candidate has major votes 
int check_winner(int vote_num,int can_num,
    char candidate_name[][20], int vote_count[], int active_candidate[]){

    int major_count = vote_num / 2;

    // iterate for all candidates
    for(int i = 0; i < can_num; i++){
        if(active_candidate[i] && vote_count[i] > major_count){
            return i;
        }
    }
    return -1;
}

// find the index of the eliminated candidate
int find_eliminate(int vote_count[], int active_candidate[], int can_num){
    int min_votes = MAX_VOTE + 1;
    int eliminate_candidate = -1;

    // update min_votes and eliminate_candidate if their votes
    // are lower
    for(int i = 0; i < can_num; i++){
        if(active_candidate[i] && vote_count[i] < min_votes){
            min_votes = vote_count[i];
            eliminate_candidate = i;
        }
    }
    return eliminate_candidate;
}

// for a voter, find highest rank active candidate
int find_vote_owner(int vote_index, int preference[][MAX_CAN],
    int active_candidate[], int can_num){

    int current_choice = -1;
    int best_preference = can_num + 1;

    // check preference rank of active candidate
    for(int c = 0; c < can_num; c++){
        if(active_candidate[c] && preference[vote_index][c] < best_preference){
            best_preference = preference[vote_index][c];
            current_choice = c;
        }
    }
    return current_choice;
}

// distributes votes after eliminating a candidate
void redistribute(int preference[][MAX_CAN], int vote_count[],
    int active_candidate[],int eliminate_candidate, int vote_num, int can_num){
    
    // loop through candidates
    for(int v = 0; v < vote_num; v++){
        int current_choice = 
            find_vote_owner(v, preference, active_candidate, can_num);
        
        // if current candidate is eliminated
        // 1. decrease vote for eliminate candidate
        // 2. finds next preferred candidate and 
        // increment vote count 
        if(current_choice == eliminate_candidate){
            vote_count[eliminate_candidate]--;

            active_candidate[eliminate_candidate] = 0;

            int new_choice = 
                find_vote_owner(v, preference, active_candidate, can_num);

            if(new_choice != -1){
                vote_count[new_choice]++;
            }

            active_candidate[eliminate_candidate] = 1;
        }
    }     
}


int stage3(int can_num, int vote_num,
    int preference[][MAX_CAN], char candidate_name[][20]){

    // print the layout for stage 3   
    printf("Stage 3\n");
    printf("=======\n");
    int vote_count[can_num];
    int active_candidate[can_num];
    
    //set active status for every candidates
    for(int i = 0; i < can_num; i++){
        active_candidate[i] = 1;
    }

    for(int i = 0; i < can_num; i++){
        vote_count[i] = 0;
    }
    
    for(int v = 0; v < vote_num; v++){
        for (int c = 0; c < can_num; c++){
            if(preference[v][c] == 1){
                vote_count[c]++;
                break;
            }
        }
    }

    // iterates logic to complete all the rounds needed
    int round = 1;
    while(1){

        // using insertion sort
        int sorted_indices[can_num];      
        sort_active_candidates(sorted_indices, active_candidate,
            can_num, vote_count, candidate_name);
        printf("round %d...\n", round);
        int active_count = 0;
        for(int i = 0; i < can_num; i++){
            if(active_candidate[i]){
                active_count++;
            }
        }

        for(int i = 0; i < active_count; i++){
            int index = sorted_indices[i];
            double vote_ratio = 100.0*vote_count[index]/vote_num;
            printf("    %-20s: %3d votes, %5.1lf%%\n", 
            candidate_name[index], vote_count[index], vote_ratio);   
        }
        printf("    ----\n");

        // check if there is a winner
        int winner = check_winner(vote_num, can_num, candidate_name,
            vote_count, active_candidate);
        if(winner != -1){
            printf("    %s is declared elected\n", candidate_name[winner]);
            return winner;
        }
        
        // find suitable candidate to eliminate
        int eliminated = find_eliminate(vote_count, active_candidate, can_num);
        printf("    %s is eliminated and votes distributed\n\n",
            candidate_name[eliminated]);

        // redistribute votes after eliminating
        redistribute(preference, vote_count, active_candidate,
            eliminated, vote_num, can_num);

        // set value for eliminated candidate 
        active_candidate[eliminated] = 0;

        round++;
    }
}    
    
// function to apply insertion sort
void sort_active_candidates(int sorted_indices[], int active_candidates[],
    int can_num, int vote_count[], char candidate_name[][20]){
    int count = 0;
    
    // get indices of active candidates
    for (int i = 0; i < can_num; i++) {
        if (active_candidates[i]) {
            sorted_indices[count++] = i;
        }
    }
    
    // Insertion sort algorithm
    for (int i = 1; i < count; i++) {
        int key = sorted_indices[i];
        int j = i - 1;

        // Move larger elements back
        while (j >= 0) {
            int current_idx = sorted_indices[j];
            
            // Check sorting conditions
            // 1. Votes of current_idx < Votes of key (descending)
            // 2. Equal votes but name of current_idx > key (alphabetical order)
            if (vote_count[current_idx] < vote_count[key] || 
                (vote_count[current_idx] == vote_count[key] && 
                strcmp(candidate_name[current_idx], candidate_name[key]) > 0)) {
                sorted_indices[j + 1] = sorted_indices[j];
                j--;
            } 
            else {
                break; // Found suitable place
            }
        }
        
        // get key into correct place
        sorted_indices[j + 1] = key;
    }
}
